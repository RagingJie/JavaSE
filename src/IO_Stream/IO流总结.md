# IO流总结
- 存储和读取数据的解决方案
- 作用：用于读写数据（本地文件、网络）
> 分类

- 方向
  - 输入流（读取）
  - 输出流（写入）
- 操作文件类型
  - 字节流（所有类型的文件）
  - 字符流（纯文本文件：windows自带的记事本打开能读懂【txt、md、xml、lrc等】）
  
## FileOutputStream书写细节
- 创建字节输出流对象
  - 细节1：参数是字符串表示的路径或者File对象都是可以的
  - 细节2：如果文件不存在会创建一个新的文件，但是要保证父级路径是存在的
  - 细节3：如果文件已经存在，则会清空文件
- 写数据
  - 细节；write方法的参数是整数，但是实际上写到本地文件中的是整数在ASCII上对应的字符
- 释放资源
  - 细节：每次使用完流之后都要释放资源
- FileOutputStream写数据的3种方式

| 方法名称                               | 说明                         |
| -------------------------------------- | ---------------------------- |
| void write(int b)                      | 一次写一个字节数据           |
| void write(byte[] b)                   | 一次写一个字节数组数据       |
| void write(byte[] b, int off, int len) | 一次写一个字节数组的部分数据 |

- 换行
  - 再次写出一个换行符就可以了
    - windows：\r\n
    - Linux：\n
    - Mac：\r
  - 细节：
    - 在windows系统中，java对回车换行进行了优化。虽然完整的是\r\n，但是我们写其中一个\r或者\n，java也可以实现换行，因为java在底层会补全。
  - 建议：
    - 不要省略，还是写全了。
- 续写
  - 如果想要续写，打开续写开关即可
  - 开关位置：创建对象的第二个参数
  - 默认false：表示关闭续写，此时创建对象会清空文件
  - 手动传递true，表示打开续写，此时创建对象不会清空文件

## FileInputStream书写细节
- 创建字节输入流对象
  - 细节：如果文件不存在，就直接报错
- 读取数据
  - 细节1：一次读一个字节，读出来的是数据在ASCII上对应的数字
  - 细节2：读到文件末尾了，read方法返回-1
- 释放资源
  - 细节：每次使用完流必须要释放资源！！！
  


## 字符流
- 字符流的底层其实就是字节流
  - 字符流 = 字节流 + 字符集
- 特点
  - 输入流：一次读一个字节，遇到中文时，一次都多个字节
  - 输出流：底层会把数据按照指定的编码方式进行编码，编程字节再写到文件中
- 使用场景
  - 对于纯文本文件进行读写操作

## 字符流
### FileReader字符流
 1.创建字符输入流对象

| 构造方法                            | 说明                       |
| ----------------------------------- | -------------------------- |
| public  FileReader(File  file)      | 创建字符输入流关联本地文件 |
| public  FileReader(String pathName) | 创建字符输入流关联本地文件 |
 - 细节：如果文件不存在，直接报错
 
 2.读取数据
 
 | 成员方法                          | 说明                         |
 | --------------------------------- | ---------------------------- |
 | public  int  read()               | 读取数据，读到末尾返回-1     |
 | public  int  read(char[]  buffer) | 读取多个数据，读到末尾返回-1 |
 - 细节1：按字节进行读取，遇到中文，一次读多个字节，读取后解码，返回一个整数
 - 细节2：读到文件末尾了，read方法返回-1
 
 3.释放资源
 
 | 成员方法             | 说明          |
 | -------------------- | ------------- |
 | public  void  close() | 释放资源/关流 |
 
 
 ### FileWriter字符流
1.创建对象

| 构造方法                                             | 说明                             |
| ---------------------------------------------------- | -------------------------------- |
| public  FileWriter(File file)                        | 创建字符输出流关联本地文件       |
| public  FileWriter(String pathName)                  | 创建字符输出流关联本地文件       |
| public  FileWriter(File file, boolean  append)       | 创建字符输出流关联本地文件，续写 |
| public  FileWriter(String pathName, boolean  append) | 创建字符输出流关联本地文件，续写 |

2.写出数据

| 成员方法                                       | 说明                   |
| ---------------------------------------------- | ---------------------- |
| void  write(int  c)                            | 写出一个字符           |
| void  write(String  str)                       | 写出一个字符串         |
| void  write(String  str,  int  off,  int  len) | 写出一个字符串的一部分 |
| void  write(char[]  cbuf)                      | 写出一个字符数组       |
| void  write(char[]  cbuf,  int off, int  len)  | 写出字符数组的一部分   |

3. 释放资源

 | 成员方法             | 说明          |
 | -------------------- | ------------- |
 | public  void  close() | 释放资源/关流 |
 | public  void  flush() | 将缓冲区中的数据，刷新到本地文件中 |
 
## 字符流原理解析
### 字符输入流
1.创建字符输入流对象

- 底层：关联文件，并创建缓冲区（长度为8192的字节数组）

2.读取数据
- 底层：
  1. 判断缓冲区中是否有数据可以读取
  2. 缓冲区没有数据：
     1. 就从文件中获取数据，装到缓冲区中，每次尽可能装满缓冲区
     2. 如果文件中也没有数据了，返回-1
  3. 缓冲区有数据：就从缓冲区中读取
     1. 空参的read方法：一次读取一个字节，遇到中文一个读多个字节，把字节解码并转成十进制返回
     2. 有参的read方法：把读取字节，解码，强转三步合并了，强转之后的字符放到数组中
     
### 字符输出流
- 写出数据
  - 将数据写入缓冲区，后将缓冲区的数据写入目的地
- 写入目的地的三种方式
  - 缓冲区满了，自动写入本地文件
  - 调用flush方法，将缓冲区中的数据，刷新到本地文件中
  - 调用close方法，将缓冲区的数据全部写入本地文件中，并释放资源，不能再将数据写入本地文件
  
  
## 字符流与字节流的使用场景
- 字节流
  - 拷贝任意类型的文件
- 字符流
  - 读取纯文本文件中的数据
  - 往纯文本文件中写出数据


## 小结
- 缓冲流有几种？
  - 字节缓冲输入流：BufferedInputStream
  - 字节缓冲输出流：BufferedOutputStream
  - 字符缓冲输入流：BufferedReader
  - 字符缓冲输出流：BufferedWriter
- 缓冲流为什么能提高性能？
  - 缓冲流自带长度为8192的缓冲区
  - 可以显著提高字节流的读写性能
  - 对于字符流提升不明显，对于字符缓冲流而言关键点是两个特有的方法
- 字符缓冲流两个特有的方法是什么？
  - 字符缓冲输入流(BufferedReader)：readLine()
  - 字符缓冲输出流(BufferedWriter)：newLine()
  
## 转换流
- 是字符流和字节流之间的桥梁
- 转换流的名字是什么？
  - 字符转换输入流：
  - 字符转换输出流：
- 转换流的作用是什么？
  - 指定字符集读写数据（JDK11之后已淘汰）
  - 字节流想要使用字符流中的方法了
## 序列化流 / 对象操作输出流
- 可以把java中的对象写到本地文件中

构造方法

| 构造方法                                      | 说明                 |
| --------------------------------------------- | -------------------- |
| public  ObjectOutputStream(OutputStream  out) | 把基本流包装成高级流 |

成员方法

| 成员方法                                   | 说明                           |
| ------------------------------------------ | ------------------------------ |
| public final void writeObject(object  obj) | 把对象序列化（写出）到文件中去 |

## 反序列化流 / 对象操作输入流

| 构造方法                                    | 说明                 |
| ------------------------------------------- | -------------------- |
| public  ObjectInputStream(InputStream  out) | 把基本流包装成高级流 |

| 成员方法                        | 说明                                       |
| ------------------------------- | ------------------------------------------ |
| public Object void readObject() | 把序列化到本地文件中的对象，读取到程序中来 |

## 序列化流 / 反序列化流的细节汇总
- 使用序列化流将对象写到文件时，需要让JavaBean类实现Serializable接口。否则，会出现NotSerializableException异常
- 序列化流写到文件中的数据是不能修改的，一旦修改就无法再次读回来了
- 序列化对象后，修改了javaBean类，再次反序列化，会不会有问题？
  - 会出现问题，会抛出**InvalidClassException**异常
  - 解决方案：给javaBean类添加serialVersionUID（序列号、版本号）
- 如果一个对象中的某个成员变量的值不想被序列化，又该如何实现？
  - 解决方案：给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程
  
## 打印流
- 分类；打印流一般是指：PrintStream，PrintWriter两个类
  - 特点1：打印流只操作文件目的地，不操作数据源
  - 特点2：特有的写出方法，可以实现数据源原样写出
  - 特点3：特有的写出方法，可以实现自动刷新，自动换行